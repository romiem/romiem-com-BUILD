{"version":3,"sources":["Blog/OpengraphSinglePageApp.tsx"],"names":["OpengraphSinglePageApp","props","article","ARTICLES","OPENGRAPH_SINGLE_PAGE_APP","className","href","language","code","codeIndex","codePackageJson","codeMetaTags","codeHomeRoute"],"mappings":"iHAAA,kGAKMA,EAA+C,SAACC,GAEpD,IAAMC,EAAUC,IAASC,0BAEzB,OACE,kBAAC,IAAD,CAAMC,UAAU,0BAEd,kBAAC,IAAD,CAAiBH,QAASA,GAExB,kBAAC,IAAD,KACE,uBAAGG,UAAU,oBAAb,0NACA,qQACA,iMAAsK,kBAAC,IAAD,CAAcC,KAAK,8CAA8CD,UAAU,iDAA3E,cAAtK,KACA,gQACA,oNACA,yCACA,6KACA,kBAAC,IAAD,CAAYE,SAAS,MAAMC,KAAMC,IACjC,gWACA,4CACA,oFACA,kBAAC,IAAD,CAAYF,SAAS,OAAOC,KAAME,IAClC,mGAAwE,8CAAxE,6DACA,4CACA,8EAAmD,kBAAC,IAAD,CAAcJ,KAAK,sCAAsCD,UAAU,iDAAnE,gBAAnD,+BACA,kBAAC,IAAD,CAAYE,SAAS,MAAMC,KAAMG,IACjC,6CACA,kGACA,kBAAC,IAAD,CAAYJ,SAAS,MAAMC,KAAMI,IACjC,iWASJH,EAAS,uKAQTC,EAAe,+CAKfC,EAAY,w3DAoDZC,EAAa,mcA0BJZ","file":"static/js/165.97f5f917.chunk.js","sourcesContent":["import React from 'react';\nimport { RouteProps } from 'react-router';\nimport { Page, ExternalLink, CodeSample, ArticleTemplate, ArticleText } from '_components';\nimport { ARTICLES } from 'articles';\n\nconst OpengraphSinglePageApp: React.FC<RouteProps> = (props) => {\n\n  const article = ARTICLES.OPENGRAPH_SINGLE_PAGE_APP;\n\n  return (\n    <Page className=\"OpengraphSinglePageApp\">\n\n      <ArticleTemplate article={article}>\n\n        <ArticleText>\n          <p className=\"mxn__fontLeading\">I love single page apps. But one perennial problem with them is that most social media crawlers from Twitter to LinkedIn cannot process the page (to generate social media previews) without server-side intervention.</p>\n          <p>The most common solution around this is to have a lightweight server side app that serves your app, but also listens for crawlers from Twitter, LinkedIn et al and serves them a barebones HTML response with Opengraph tags embedded.</p>\n          <p>Given I was working on a small/medium sized SPA, this was overkill for my purposes, and so I investigated other options. I eventually came across a library called <ExternalLink href=\"https://github.com/stereobooster/react-snap\" className=\"u-anchor u-anchor--accent u-anchor--underline\">react-snap</ExternalLink>.</p>\n          <p>React-snap is a static site generator that works by firing up a Chromium browser instance, visits your root path, and scans for all internal links. It then recursively navigates to each of those links and repeats the process.</p>\n          <p>Needless to say, this solution is only practical if you have a SPA with known or fixed routes. Dynamic URLs (like those used for usernames in social networks) would not be feasible.</p>\n          <h2>index.tsx</h2>\n          <p>In the entry index.tsx file of your app, you need to replace ReactDOM.render with a conditional ReactDom.hydrate statement like the following:</p>\n          <CodeSample language=\"tsx\" code={codeIndex} />\n          <p>The hydrate call is used when the HTML has been pre-rendered (in our case, by a static site generator, but can also be server-side) and therefore we can tell React to preserve it and only attach event handlers. Note this is only occurs on startup of the SPA - after this point, the application functions as a regular SPA.</p>\n          <h2>package.json</h2>\n          <p>Next, we add the following to your package.json file:</p>\n          <CodeSample language=\"json\" code={codePackageJson} />\n          <p>And that's our static site generator setup complete! Whenever we run <strong>yarn build</strong>, we now have our static site output to the build folder.</p>\n          <h2>MetaTags.jsx</h2>\n          <p>Next I create a helper component to wrap around <ExternalLink href=\"https://github.com/nfl/react-helmet\" className=\"u-anchor u-anchor--accent u-anchor--underline\">react-helmet</ExternalLink> to render all my metatags.</p>\n          <CodeSample language=\"tsx\" code={codeMetaTags} />\n          <h2>HomeRoute.tsx</h2>\n          <p>All that's left to do is call the component in each of your routes.</p>\n          <CodeSample language=\"tsx\" code={codeHomeRoute} />\n          <p>That wraps up the process I took to convert my SPA into a static site, with support for social media sharing previews. For anyone interested, the deployment environment for this SPA was GitHub Pages. If this helped you out, or you have any questions, drop me a line on Twitter or Instagram - I'd love to hear from you!</p>\n        </ArticleText>\n\n      </ArticleTemplate>\n\n    </Page>\n  );\n};\n\nconst codeIndex =\n`const rootElm = document.getElementById('root')!;\nif (rootElm.hasChildNodes()) {\n  ReactDOM.hydrate(app, rootElm);\n} else {\n  ReactDOM.render(app, rootElm);\n};`\n\nconst codePackageJson =\n`\"scripts\": {\n  \"postbuild\": \"react-snap\"\n}`;\n\nconst codeMetaTags =\n`import React from 'react';\nimport { Helmet } from 'react-helmet';\n\ntype MetaTagsProps = {\n  title: string;\n  description: string;\n  ogType?: string;\n  // Relative path to your image - this component will fully qualify the URL for you\n  image?: string;\n};\n\nconst MetaTags: React.FC<MetaTagsProps> = (props) => {\n\n  // Create a REACT_APP_PUBLIC_URL property in your env file which is your fully qualified domain e.g. https://www.mydomain.com\n  const PUBLIC_URL = process.env.REACT_APP_PUBLIC_URL!;\n  const url = PUBLIC_URL + window.location.pathname;\n  const imageUrl = PUBLIC_URL + props.image;\n\n  return (\n    <Helmet>\n      <title>{props.title}</title>\n      <meta name=\"description\" content={props.description} />\n      <meta property=\"og:type\" content={props.ogType} />\n      <meta property=\"og:site_name\" content=\"YOUR SITE NAME\" />\n      <meta property=\"og:title\" content={props.title} />\n      <meta property=\"og:description\" content={props.description} />\n      <meta property=\"og:url\" content={url} />\n      <meta property=\"og:image\" content={imageUrl} />\n      <meta property=\"og:image:width\" content=\"1200\" />\n      <meta property=\"og:image:height\" content=\"800\" />\n      <meta property=\"twitter:card\" content=\"summary_large_image\" />\n      <meta property=\"twitter:site\" content=\"@YOUR_TWITTER_HANDLE\" />\n      <meta property=\"twitter:creator\" content=\"@YOUR_TWITTER_HANDLE\" />\n      <meta property=\"twitter:title\" content={props.title} />\n      <meta property=\"twitter:description\" content={props.description} />\n      <meta property=\"twitter:url\" content={url} />\n      <meta property=\"twitter:image\" content={imageUrl} />\n    </Helmet>\n  );\n};\n\n\nMetaTags.defaultProps = {\n  title: '',\n  description: '',\n  ogType: 'website',\n  image: '/images/icons/logo-opengraph.jpg', // point to your default Opengraph image\n};\n\nexport { MetaTags };`;\n\nconst codeHomeRoute =\n`import React from 'react';\nimport { MetaTags } from '_components';\nimport './HomeRoute.scss';\nimport imgBanner from './images/banner.jpg';\n\nconst HomeRoute: React.FC = (props) => {\n\n  return (\n    <div className=\"HomeRoute\">\n\n      <MetaTags\n        title=\"My page title\"\n        description=\"My page description\"\n        image={imgBanner}\n      />\n\n      <h1>Hello World!</h1>\n\n    </div>\n  );\n};\n\nexport { HomeRoute };`;\n\nexport { OpengraphSinglePageApp };\nexport default OpengraphSinglePageApp;\n"],"sourceRoot":""}